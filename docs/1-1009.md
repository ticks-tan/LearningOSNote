## 结构体

Rust中结构体也是作为一种复合类型，包含多种其他类型的集合，并允许为其定义函数操作、Trait实现等。创建结构体为成员赋值时需要明确指定内部成员名称，顺序没有要求，如果使用变量初始化，且变量名称与成员名称一致时可省略成员名称。

如果需要用已有的结构体对象初始化新的结构体，但是其中某些字段需要自己定义则可以使用 `..` 语法简化代码：

```rust
// 定义结构体
struct Person
{
    name: String,
    age: u32
}
let person = Person{age: 20, name: "XXX".to_string()};
let age = 21;
let person1 = Person{age, ..person};
```

如果字段使用引用，则需要注意引用的生命周期应该至少与结构体对象本身一样长。

元组结构体是一种类似元组的结构体，其中只包含了成员的类型，没有名称，使用时可以像访问元组一样进行访问：

```rust
struct Color(u8, u8, u8);

let color = Color(23, 27, 35);
let (r, g, b) = color;
// ....
```

## 枚举

枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。枚举项可以包含值，并且枚举中不同项不必包含相同类型的值！这一点比C/C++中枚举要更加灵活和强大，相对应的，在为枚举赋值时，如果是包含值的枚举项，需要为其提供值，使用时可以使用模式匹配进行访问。


## Option

Option是一种特殊的枚举，是一种可以为空值的结构，`Some(T)` 表示其中有值，`None` 表示没有值，可以通过模式匹配来判断或者使用 `option.is_some()` 和 `option.is_none()` 判断。使用时由于 Rust 的 preinclude 不用 `Option::Some(xxx)`，可以直接使用：`let opt = Some(XXX);` 。

```rust
enum Option<T> {
    Some(T),
    None
}
```

## 模式匹配

Rustz最常用的模式匹配是 `match` 和 `if let` ，其中 match 跟 C/C++ 中 switch 较像，对一个值进行匹配，满足某个模式就执行该模式下代码片段。

```rust
match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    // _ 表示其他所有情况，一种通配符，也能在其他地方如函数参数作为占位符
    _ => 表达式3
}
```

模式匹配也是一种表达式，所以可以返回值，不过要求所有模式分支返回同一种类型，而 `if let` 算是对模式匹配的简化，让我们只关心需要的模式和值，其他情况进行忽略，通常用于值的匹配如 `Option` 和 `Result` 。

Rust 标准库还提供了一个非常实用的宏：matches!，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 true or false。

## 错误处理与Result

Result也是Rust提供的一种特殊枚举，它包含两种情况，一种正确值，一种错误值，使用时同样可以不用指定 `Result` 作用域。

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

很多时候我们都会进行错误处理，但是由于Rust模式匹配很多时候写起来比较麻烦，如果函数中每个地方都进行一大堆的 `match Result` 会非常难看，如果使用 `unwrap` 处理也会失去更优雅的错误处理。最常用的就是将 `Result` 作为函数返回值，错误处理在某个固定的地方进行处理，使用 `?` 语法来进行错误传递，必要时使用 `map_err` 进行错误类型转换。

```rust
fn do_something(s: &String) -> Result<u32, MyErr>
{
    let num = s.parse::<u32>().map_err(|_e| MyErr(XXX))?
    Ok(num)
}

// 常规 Option + match
fn do_something(s: &String) -> Option<u32>
{
    let num = s.parse::<u32>();
    if let Ok(num) = num {
        Some(num)
    }else {
        // 错误处理
        None
    }
}

```

## 泛型与特征

Rust泛型使用 `<T>` 进行描述，其中 `T` 为泛型类型，可以取其他名称比如 `Type` 等，类型根据实例化代码确定实际类型，泛型可以用作函数参数、返回值、结构体字段类型、枚举类型等。

```rust
// 结构体
struct XXX<T> {
    xxx: T,
    yyy: u32,
}

// 结构体函数，需要在 impl处也声明泛型类型，这样Rust才知道函数参数中的 T 是不是实际类型
impl<T> XXX<T> {
    fn new(xxx: T) -> Self{
        XXX{xxx}
    }
}

// 函数参数、返回值
fn func<T>(xxx: T) -> T {
    // ....
}
```

特征 `Trait` 用于定义一类行为，可以为所有符合特征的类型实现该 `Trait` ，让类型具有该特征的行为，同时可以使用特征对泛型类型进行约束，类似于C++中模板 `concept` 。

```rust
// 要使用 println 打印需要 T 类型实现 Display 特征
fn test<T: Display>(xxx: T) {
    println!("xxx = {}", xxx);
}
```


## 包与模块

Rust包管理一些概念：

- 项目(Package)：可以用来构建、测试和分享包
- 工作空间(WorkSpace)：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间
- 包(Crate)：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行
- 模块(Module)：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元

对于 Rust 而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。

Package 就是一个项目，因此它包含有独立的 Cargo.toml 文件，以及因为功能性被组织在一起的一个或多个包。一个 Package 只能包含一个库(library)类型的包，但是可以包含多个二进制可执行类型的包。

库类型的 Package 只能作为第三方包共其他项目引用，不能执行，如果需要执行，可以单独创建二进制包。

一个Package中默认唯一的库包文件在 `src/lib.rs` ，默认二进制包在 `src/main.rs` 编译后二进制文件名称与Package同名，当然这些都是可以进行修改的。

Rust模块类似C++中命名空间，但是增加了一些其他功能如可见性、导出、导入等。默认模块为对外不可见，要让其他模块可见需要手动指定 `pub` 关键字，父模块内容对子模块是可见的，但子模块内容对父模块是不可见的。

模块使用 `mod` 声明，模块可以跟文件分离，模块树对应目录树中文件，使用 `mod xxx;` 声明目录下同名模块。

使用 `use` 关键字可以引入模块，使用 `as` 关键字可以给模块取一个特别的名字，避免多个同名模块，在 `use` 前使用 `pub` 关键字可以将 use 引用传递，其他模块导入当前模块时这个use的模块也会被导入。