## 基本概念

- 关键字

省略 ...

- 变量

Rust中变量跟常规编程语言不同，因为Rust语言变量不是默认“可变”的，即不能直接进行修改，而是需要加上 **`mut`** 关键字才能修改，比如：

```rust
fn main()
{
    let a = 12;
    // a = 13; error，默认不可以修改
    let mut b = 12;
    b = 14; // ok, 加上 mut 关键字后可修改，类似C++中 mutable ?
}
```

Rust是强类型语言，基本类型主要有 **有符号的(i8, i16, i32, i64, isize)**、**无符号的(u8, u16, u32, u64, usize)**、**浮点型(f32, f64)**，bool类型以及字符串切片 **&str** ，其中 `isize`和`usize`大小是与平台有关的。

如果在变量声明时提供初始值，rust会自动推导变量类型，但如果不提供初始值，则需要我们手动指定变量类型，而之后如果需要使用这个变量，则变量必须拥有初始值！

```rust
fn main() 
{
    let a = 12; // ok, a 是 i32 类型
    // let b; error
    let b : i32;
    // println!("b = {}", b); error，b没有初始值
    b = 12;
    println!("b = {}", b); // ok, b进行了初始值设定

}
```

> 对于const类型以及static变量，需要注意定义时必须同时指定初始值以及变量类型，不会自动推导！

需要注意的是Rust中 `()` 也是一种类型！被称作**单元类型**，通常用于占位。

- 流程控制

Rust支持条件控制 `if`，循环控制 `while`、`for` 和 `loop` 。

Rust `for` 循环不支持C风格的for循环，对其进行了简化，支持指定一个范围或者集合的循环，跟python的循环比较像。

`loop` 循环是一个 “死循环”，需要使用 `break` 进行跳出，等价于 `while(true){}`：

```rust
fn main() 
{
    //  [0, 5)
    for i in 0..5 {
        // ...
    }
    //  [1,5]
    for i in 1..=5 {
        // ...
    }

    loop {
        // xxx
        break; // quit
    }

}
```

- 语句与表达式

Rust中很多时候可以省略 `return` 或者多余的赋值语句，这得益于Rust表达式返回一个值的作用。比如可以在函数结尾使用一个表达式代替`return`语句返回一个值。

语句是一个操作，而表达式必须返回值（可以是单元类型）且不能有分号，语句块也是一个表达式，如果语句块最后是表达式，则整个语句块会返回这个结尾表达式值，如果结尾是语句，也会返回单元类型！这样的好处是使得我们编写起来更加的灵活：

```rust
fn main()
{
    let (ia, ib) = (1, 2); // 语句
    let a = if (ia < ib) {
            ib // 表达式
        }else {
            ia
        }; // 整个if语句块是一个表达式

    let b = {}; // b 为单元类型,可以赋值，但无法使用
}
```

- 引用与借用

rust通过所有权管理内存，编译器在编译阶段根据规则检查。

rust所有权规则如下：
>   1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者。
>   2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者。
>   3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)。

对于没有实现 `Copy` trait 的类型，赋值语句会转移所有权，被转移所有权的变量就无法被使用了，如果使用则编译器会在编译阶段检查出来并给出提醒，不过对于内置类型默认可以拷贝，所以像 `i32` 这种类型变量是可以直接赋值的。

Rust基础类型支持 Copy trait:
    
- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型，char
- 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是
- 不可变引用 &T ，但是需要注意可变引用 &mut T 是不可以 Copy 的

像这样所有权Move来去的对于编写者非常麻烦，好在Rust提供了 **借用** 。顾名思义就是借用所有权变成对值的引用，在不使用后（结束作用域）归还所有权，借用同样有几条规则需要遵守：

> 1. 引用必须有效。
> 2. 同一时间可以有多个不可变引用，但只能有一个可变引用。

获取一个值引用最简单就是对它取地址，使用时需要解引用：

```rust
fn main()
{
    let a = 12;
    let b = &a;

    println!("b = {}", *b);
}
```

- 函数

Rust 函数定义格式为：`fn 函数名(参数:参数类型) -> 返回值类型;` ，没有返回值可以忽略返回值类型。


